cd sites/admin && npm start
rfc  rcc 创建文件结构 快捷方式
重新学习 react 查漏补缺
jsx中：
class -> className
for -> htmlFor   <label htmlFor='usename'>用户名</lable> <input id='usename'/>
for 属性规定 label 与哪个表单元素绑定。
React推荐行内样式
注释{/* */}
React btn中的点击事件this.handleClick不要加 (),和vue不同

call apply 改变this指向 并且自动执行  bind改变this指向，但不执行

es7 class中的属性可以直接用a = (){} 这种方式定义，不用强制写在constructor中
class A{constructor(){} c=333}; (new A()).c ===333
React并不会真正绑定到每个具体的元素上采用的是事件代理 的方式
事件代理：https://www.bilibili.com/video/BV1dP4y1c7qd?p=12&spm_id_from=pageDriver
this.refs.mytext
a = [1,2,3] b= [...a] ||  b = a.slice() || b = a.concat(); //避免引用赋值

1.三目{this.state.lists.length === 0 ? <div>暂无待办事项</div>:null} 
2.{this.state.lists.length === 0 && <div>暂无待办事项</div>}
3.<div className={条件?'hidden':''}>暂无待办事项</div>

富文本创建的内容  https://www.bilibili.com/video/BV1dP4y1c7qd?p=20&spm_id_from=pageDriver
(<div  dangerouslySetInnerHTML={{__html: this.state.content}} /> )// 注意这里是两个下下划线 __html

setState同步和异步讲解
setState有第二个参数，它是一个回调函数 状态和DOM更新完成
setState在一个同步的逻辑中 是个异步更新状态 更新真实DOM
setState在一个异步的逻辑中 是个同步更新状态 同步更新真实DOM(axios也是一个异步环境)
setTimeout(()=>{setState},0)
setState 会重新调用render;

betterScroll 
类 组件自带props属性； this.props
prop-types
属性验证 和类的静态属性一样 
Navbar.propTypes = { title : 验证是不是字符串的方法} // static propTypes = {}
Navbar.defaultProps = { title : 默认属性}
传多个属性参数 {...obj}
函数式组件，没有this  可以直接传形参 function(props){return } // 和类式组件的传参区别

父子通信

如果通过ref来访问表单 中 input，是非受控的，如果给这个表单中的input提供一个默认值 value='kerwin'，会发现这个非受控的，其它内容也输入不了了；
这种情况要把默认值的属性名改成 'defaultValue'

受控组件  input 中的vlaue = {this.state.username} react中onInput 和 onChange的行为是一样的 同效的
onChange = {(e)=>{this.setState({username:e.target.value})}}

过滤列表方案优化； 1.有一个备份数据源，占内存 2.利用受控组件来完成，不用备份数据
父子通信 父 传子 属性    ；  子传父 回调函数；

使用--save安装的打包都打进去，
使用--save-dev安装的不进行打包，故打包大小就有区别，根据自己的需要进行选择--save 还是--save-dev
只是在开发过程中需要的工具或者文件我们 使用 --save-dev 即可


利用context来完成传值  
1.定义const GlobalContext = React.createContext();
2.App变成供应商 <GlobalContext.Provider value={object}>
3.子组件成消费者 <GlobalContext.Consumer>   里面是一个回调函数，同时把值传进来 (value)=>{}
老的生命周期
(1) componentWillMount ,在ssr中 这个方法将会被多次调用， 所以会重复触发多遍，同时在这里如果绑定事件，
将无法解绑，导致内存泄漏 ， 变得不够安全高效逐步废弃。
(2) componentWillReceiveProps 外部组件多次频繁更新传入多次不同的 props，会导致不必要的异步请求
(3) componetWillupdate, 更新前记录 DOM 状态, 可能会做一些处理，与componentDidUpdate相隔时间如果过
长， 会导致 状态不太信
新的生命周期
（1）getDerivedStateFromProps 第一次的初始化组件以及后续的更新过程中(包括自身状态更新以及父传子) ，
返回一个对象作为新的state，返回null则说明不需要在这里更新state
 (2) getSnapshotBeforeUpdate 取代了 componetWillUpdate ,触发时间为update发生的时候，在render之后
dom渲染之前返回一个值，作为componentDidUpdate的第三个参数。

// https://www.swiper.com.cn/ swiper官网


Immutable.js 的几种数据类型
List: 有序索引集，类似JavaScript中的Array。
Map: 无序索引集，类似JavaScript中的Object。
将一个js数据转换为Immutable类型的数据
用法：fromJS(value, converter)
const obj = Immutable.fromJS({a:'123',b:'234'},function (key, value, path) {
        console.log(key, value, path)
        return isIndexed(value) ? value.toList() : value.toOrderedMap())
    })
将一个Immutable数据转换为JS类型的数据
用法：value.toJS()
-----------------------
immer.js
比起Facebook亲自打造的immutable.js，immer.js比immutable.js体积更小，不需要去记immutable.js里像Collection、List、Map、Set、Record这样的数据结构，使用的时候还需要toJS()转换成数组和对象才能正常使用。

 