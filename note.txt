cd sites/admin && npm start
项目分支不同代码不同
rfc  rcc 创建文件结构 快捷方式
重新学习 react 查漏补缺
jsx中：
class -> className
for -> htmlFor   <label htmlFor='usename'>用户名</lable> <input id='usename'/>
for 属性规定 label 与哪个表单元素绑定。
React推荐行内样式
注释{/* */}
React btn中的点击事件this.handleClick不要加 (),和vue不同

call apply 改变this指向 并且自动执行  bind改变this指向，但不执行

es7 class中的属性可以直接用a = (){} 这种方式定义，不用强制写在constructor中
class A{constructor(){} c=333}; (new A()).c ===333
React并不会真正绑定到每个具体的元素上采用的是事件代理 的方式
事件代理：https://www.bilibili.com/video/BV1dP4y1c7qd?p=12&spm_id_from=pageDriver
this.refs.mytext
a = [1,2,3] b= [...a] ||  b = a.slice() || b = a.concat(); //避免引用赋值

1.三目{this.state.lists.length === 0 ? <div>暂无待办事项</div>:null} 
2.{this.state.lists.length === 0 && <div>暂无待办事项</div>}
3.<div className={条件?'hidden':''}>暂无待办事项</div>

富文本创建的内容  https://www.bilibili.com/video/BV1dP4y1c7qd?p=20&spm_id_from=pageDriver
(<div  dangerouslySetInnerHTML={{__html: this.state.content}} /> )// 注意这里是两个下下划线 __html

setState同步和异步讲解
setState有第二个参数，它是一个回调函数 状态和DOM更新完成
setState在一个同步的逻辑中 是个异步更新状态 更新真实DOM
setState在一个异步的逻辑中 是个同步更新状态 同步更新真实DOM(axios也是一个异步环境)
setTimeout(()=>{setState},0)
setState 会重新调用render;

betterScroll 
类 组件自带props属性； this.props
prop-types
属性验证 和类的静态属性一样 
Navbar.propTypes = { title : 验证是不是字符串的方法} // static propTypes = {}
Navbar.defaultProps = { title : 默认属性}
传多个属性参数 {...obj}
函数式组件，没有this  可以直接传形参 function(props){return } // 和类式组件的传参区别

父子通信

如果通过ref来访问表单 中 input，是非受控的，如果给这个表单中的input提供一个默认值 value='kerwin'，会发现这个非受控的，其它内容也输入不了了；
这种情况要把默认值的属性名改成 'defaultValue'

受控组件  input 中的vlaue = {this.state.username} react中onInput 和 onChange的行为是一样的 同效的
onChange = {(e)=>{this.setState({username:e.target.value})}}

过滤列表方案优化； 1.有一个备份数据源，占内存 2.利用受控组件来完成，不用备份数据
父子通信 父 传子 属性    ；  子传父 回调函数；

使用--save安装的打包都打进去，
使用--save-dev安装的不进行打包，故打包大小就有区别，根据自己的需要进行选择--save 还是--save-dev
只是在开发过程中需要的工具或者文件我们 使用 --save-dev 即可


利用context来完成传值  
1.定义const GlobalContext = React.createContext();
2.App变成供应商 <GlobalContext.Provider value={object}>
3.子组件成消费者 <GlobalContext.Consumer>   里面是一个回调函数，同时把值传进来 (value)=>{}
老的生命周期
(1) componentWillMount ,在ssr中 这个方法将会被多次调用， 所以会重复触发多遍，同时在这里如果绑定事件，
将无法解绑，导致内存泄漏 ， 变得不够安全高效逐步废弃。
(2) componentWillReceiveProps 外部组件多次频繁更新传入多次不同的 props，会导致不必要的异步请求
(3) componetWillupdate, 更新前记录 DOM 状态, 可能会做一些处理，与componentDidUpdate相隔时间如果过
长， 会导致 状态不太信
新的生命周期
（1）getDerivedStateFromProps 第一次的初始化组件以及后续的更新过程中(包括自身状态更新以及父传子) ，
返回一个对象作为新的state，返回null则说明不需要在这里更新state
 (2) getSnapshotBeforeUpdate 取代了 componetWillUpdate ,触发时间为update发生的时候，在render之后
dom渲染之前返回一个值，作为componentDidUpdate的第三个参数。
memo的作用是为了减少组件重新render过程中导致组件的重复渲染，而得到性能上的提升。
但是 Context 发生的变化是无法通过 memo 进行优化的，这个大家需要知道的一个点。

Immutable.js 的几种数据类型
List: 有序索引集，类似JavaScript中的Array。
Map: 无序索引集，类似JavaScript中的Object。
将一个js数据转换为Immutable类型的数据
用法：fromJS(value, converter)
const obj = Immutable.fromJS({a:'123',b:'234'},function (key, value, path) {
        console.log(key, value, path)
        return isIndexed(value) ? value.toList() : value.toOrderedMap())
    })
将一个Immutable数据转换为JS类型的数据
用法：value.toJS()
-----------------------
immer.js
比起Facebook亲自打造的immutable.js，immer.js比immutable.js体积更小，不需要去记immutable.js里像Collection、List、Map、Set、Record这样的数据结构，使用的时候还需要toJS()转换成数组和对象才能正常使用。

useRef
useSearchParams
ts  as const 
why did you render
codesandbox.io
尽量避免把对象类型放在依赖项里
无限循环渲染问题  useMemo useCallback
基本类型和组件状态可以放在依赖里；非组件状态的对象绝不可以放在依赖里
//eslint-disable-next-line  react-hooks/exhaustive-deps
JSX.Element
组件组合 component composition

-----------------------
React 系列教程之 Mobx  
https://www.bilibili.com/video/BV1tL4y1h7ND/ 
解决不能重新render方法：
1.@observer要放在最里层componentDidMount 触发后才能重新render
2.(目前没用到这个方法)-注入到组件中并调用action时，数据能发生改变，但页面始终不会重新渲染，找遍了全网，最后发现时mobx在6以后的版本，
必须在构造函数中调用方法makeObservable()或者makeAutoObservable()。调用后者的时候可以不用再为字段和方法添加@observable和@action。

装饰器就是个语法糖……实际上用装饰器和 observer(component) 是一样的效果
@computed get cartProducts 计算属性 不渲染相应的效果后来发现是版本的问题
在constructor 构造函数中加 makeObservable(this) 这个才解决

mobx enforceActions 也被称为“严格模式”。
在严格模式下，不允许在 action 外更改任何状态。 可接收的值:
“never” (默认): 可以在任意地方修改状态
“observed”: 在某处观察到的所有状态都需要通过动作进行更改。在正式应用中推荐此严格模式。
“always”: 状态始终需要通过动作来更新(实际上还包括创建)。
具体使用：
import { configure } from 'mobx';
configure({ enforceActions: 'observed' });
非严格模式下，store数据操作可以不用runInAction包裹，不推荐；
严格模式下，异步数据操作需要用runInAction包裹（包含捕获异步错误后的数据操作），推荐。

